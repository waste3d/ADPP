# ADPP - Asynchronous Data Processing Pipeline

![Go Version](https://img.shields.io/badge/Go-1.21+-00ADD8?style=for-the-badge&logo=go)
![Docker](https://img.shields.io/badge/Docker-20.10+-2496ED?style=for-the-badge&logo=docker)
![PostgreSQL](https://img.shields.io/badge/PostgreSQL-14-336791?style=for-the-badge&logo=postgresql)
![RabbitMQ](https://img.shields.io/badge/RabbitMQ-3-FF6600?style=for-the-badge&logo=rabbitmq)

## О проекте

**ADPP** — это пет-проект, демонстрирующий создание высокопроизводительной и масштабируемой бэкенд-системы на Go. Основная цель проекта — показать навыки проектирования распределенных систем, асинхронной обработки задач и работы с современным технологическим стеком.

Проект имитирует систему, которая должна быстро принимать запросы от пользователей, ставить ресурсоемкие задачи в очередь на фоновую обработку и выполнять их, не блокируя основной API.

### Ключевые концепции, продемонстрированные в проекте:

*   **Микросервисная архитектура:** Система разделена на два независимых сервиса.
*   **Асинхронная обработка:** Использование очереди сообщений (RabbitMQ) для decoupling'а сервисов и отложенного выполнения задач.
*   **Чистая архитектура:** Код структурирован по слоям (API, Storage, Domain) для лучшей читаемости и тестируемости.
*   **Контейнеризация:** Весь проект и его зависимости запускаются в Docker-контейнерах одной командой.
*   **Конфигурация через окружение:** Следование принципам 12-Factor App.

## Архитектура

Система состоит из следующих компонентов:

1.  **Main Service (API)**: Сервис на Go, написанный с использованием фреймворка Gin. Его задача — принимать HTTP-запросы, валидировать их, быстро сохранять задачу в базу данных со статусом `pending` и отправлять сообщение в очередь. Он всегда должен отвечать пользователю максимально быстро.
2.  **Worker Service**: Фоновый обработчик на Go. Он слушает сообщения из очереди RabbitMQ, забирает задачи, выполняет "тяжелую" работу (например, сложные вычисления) и обновляет статус и результат задачи в базе данных.
3.  **PostgreSQL**: Реляционная база данных для хранения состояния задач.
4.  **RabbitMQ**: Брокер сообщений, который служит буфером между `Main Service` и `Worker Service`.

### Схема взаимодействия

[Client] -> [POST /jobs] -> [Main Service] ---(сохраняет Job status="pending")--> [PostgreSQL]
|
+----(отправляет Job ID)----> [RabbitMQ]
|
| (слушает очередь)
V
[Worker Service] ---(обновляет Job status="completed", result=...)--> [PostgreSQL]

## Технологический стек

*   **Язык:** Go
*   **Веб-фреймворк:** Gin
*   **ORM:** GORM
*   **Брокер сообщений:** RabbitMQ
*   **База данных:** PostgreSQL
*   **Инфраструктура:** Docker, Docker Compose

## Быстрый старт

Для запуска проекта на локальной машине необходимы **Git** и **Docker**.

**1. Клонируйте репозиторий:**

```bash
git clone https://github.com/waste3d/ADPP.git
cd ADPP
```

2. Создайте файл конфигурации:

Проект использует .env файл для конфигурации. Вы можете скопировать пример:
```bash
cp .env.example .env
```

Вносить изменения в .env не требуется для локального запуска, все значения по умолчанию уже настроены для работы с Docker Compose.

3. Запустите проект:

Эта команда соберет образы и запустит все контейнеры в фоновом режиме.

```bash
docker-compose up --build -d
```

4. Проверка статуса:

Убедитесь, что все контейнеры успешно запустились:

```bash
docker-compose ps
```

Вы также можете следить за логами сервисов:

```bash
docker-compose logs -f main-service worker-service
```

# Использование API

Сервис main-service будет доступен по адресу http://localhost:8080.

Создание новой задачи

Метод: POST

Эндпоинт: /jobs

Тело запроса:

```JSON
{
  "input": 42
}
```
Пример с curl:

```Bash
curl -X POST \
  http://localhost:8080/jobs \
  -H 'Content-Type: application/json' \
  -d '{"input": 42}'
```
Успешный ответ (201 Created):

```JSON
{
  "job_id": 1
}
```

**Как его использовать:**

1.  Создайте в корне вашего проекта файл `README.md`.
2.  Скопируйте в него этот текст.
3.  Не забудьте также создать файл `.env.example` рядом с `docker-compose.yml`, чтобы команда `cp .env.example .env` работала. Его содержимое должно быть таким же, как у вашего `.env` файла, возможно, без реальных паролей в будущем.

